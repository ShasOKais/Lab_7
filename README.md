# Лабораторная работа № 7. «Группировка и сохранение»

Тип приложения: GUI; язык: без ограничений.

Развитие приложения из Л.Р.6:

*	Группировка, разгруппировка объектов и групп объектов (сгруппированные объекты изменяются только совместно). Реализация группировки объектов должна быть выполнена с помощью паттерна Composite:
 
    +	выделение нескольких объектов в рабочей области и их группировка (с изъятием из хранилища и помещением в специальный объект класса Group, который затем обратно помещается в хранилище);
   
    +	группа ведет себя как единый объект: перемещается, сохраняет относительное положение входящих в нее объектов, не выходит за границы;

    +	в группу могут входить другие группы, и т.д.

*	Реализация сохранения и восстановления хранилища из Л.Р.3 с помощью паттерна Abstract Factory или Factory Method:

    +	сохранение всех объектов хранилища в (человеко-читаемый) текстовый файл

    +	восстановление всех объектов хранилища из текстового файла

*	Факультативно:

    +	манипуляции объектами выполняются не только с помощью клавиатуры, но и с помощью мыши

    +	реализация команд пользовательского интерфейса с помощью паттерна Command (с возможностью функциональности «undo» - отмены последовательности операций)

    +	команды пользовательского интерфейса и типы объектов создаются с помощью подключаемых динамических библиотек (DLL)

Функция хранилища, которая занимается сохранением объектов в некоторый файл, не должна знать о деталях организации сохраняемых объектов. Она должна вызывать виртуальную функцию save() у базового объекта, тем самым, предоставляя объекту самому возможность записать в файл то, что ему нужно для восстановления.

Примерный алгоритм сохранения хранилища в текстовый файл должен выглядеть так:
*	Открой файл для записи
*	Сохрани в файл информацию о количестве объектов
*	Для каждого объекта хранилища:
    +	Вызови функцию save()
*	Закрой файл
 
Самой сложной для реализации хранилища является функция восстановления объектов из хранилища. Понятно, что наряду с виртуальной функцией save() у базового объекта, у него должна быть и виртуальная функция load(). Однако проблема состоит в следующем. Пусть требуется загрузить очередной объект из хранилища. Надо вызвать метод load() у объекта, но объект ведь еще не создан! А объект какого класса необходимо создать, чтобы вызвать у него метод load()? 

Примерный алгоритм загрузки содержимого хранилища из текстового файла должен выглядеть так:
*	Открой файл для чтения
*	Прочитай информацию о количестве объектов
*	Столько раз, сколько объектов нужно создать:
    +	Узнай из файла, объект какого класса нужно создать
    +	Создай объект этого класса
    +	Вызови у объекта функцию load()
*	Закрой файл

